###### **二叉树**

二叉树性质

度数和=结点数-1=分支数=n1+2n2

n0+n1+n2-1=n1+2n2

可得n0=n2+1    叶子结点数等于双分支结点数加一



1.满二叉树(所有分支结点都有双分支且叶子结点都在树的最下层)

每一层的结点数为2^(h-1)

总结点数为2^h-1            

2.完全二叉树

最多只有下面两层的结点度数小于2

并且最下面一层的叶结点都排在最左边

就是满二叉树最下层从右往左删除了几个孩子(可以是奇数个)

性质1:当结点数n为奇数时一度结点的个数n1=0;

结点数n为偶数时,n1=1;

性质2  编号小于[n/2]向下取整的结点都为分支结点,大于的都为叶子结点

性质3 编号为i的左孩子为2i 右孩子为2i+1;  双亲为[i/2]向下取整

性质3 若完全二叉树的结点数已知,则n0,n1,n2都已知{由n的奇偶确定n1,再由n=n0+n1+n2  和n0=n2+1 确定n0,n2}  

 并且树高h=[log2(i)]向下取整+1





树,二叉树,森林间的转换

树->二叉树{1给兄弟加边,2给长子外的孩子去线,3层次调整}

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203192940155.png" alt="image-20241203192940155" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203192907443.png" alt="image-20241203192907443" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193025219.png" alt="image-20241203193025219" style="zoom:50%;" />

森林->二叉树

![image-20241203193115437](C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193115437.png)



<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193159695.png" alt="image-20241203193159695" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193229148.png" alt="image-20241203193229148" style="zoom:50%;" />

第一棵二叉树不动,第二棵二叉树树作为第一颗的有孩子,第三颗作为第二颗的有孩子以此类推,得下图

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193255819.png" alt="image-20241203193255819" style="zoom:50%;" />



二叉树->树

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193620874.png" alt="image-20241203193620874" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193703267.png" alt="image-20241203193703267" style="zoom:50%;" />

二叉树->森林

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193758277.png" alt="image-20241203193758277" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193826223.png" alt="image-20241203193826223" style="zoom:50%;" />

<img src="C:\Users\zzy13\AppData\Roaming\Typora\typora-user-images\image-20241203193916842.png" alt="image-20241203193916842" style="zoom:50%;" />



创建

```c++
TreeNode* creatTree()
{
    TreeNode* T;
   int data;
    cin >>data;//通过输入的ch是否是‘#’来判断该节点是否有孩子节点

    if (data ==-1) //'#'代表传入的是空结点
    {
        //此时为空结点
        return NULL;
    }
    else
    {
        
        //不为空
        T = (TreeNode*)malloc(sizeof(TreeNode));
        T->data = data;
        //创建左子树，逻辑一致，进行递归
        T->left = creatTree();
        //创建右子树，逻辑一致，进行递归
        T->right = creatTree();
        return T;

    }
}
```



先序遍历

```c++

void preorder(TreeNode*& p) {
    if (p!=NULL)
    {
        cout << p->data;
        preorder(p->left);
        preorder(p->right);
    }
}
```



输出叶子结点

```c++
void DispLeave(TreeNode* T) {
    if (T!=NULL)
    {
        if (T->left==NULL&&T->right==NULL)
        {
            cout << T->data;
        }
        else {
            DispLeave(T->left);
            DispLeave(T->right);
        }
    }
}
```



第k层的结点数

```c++
void nodeofH(TreeNode* T, int h,int k,int &n) {
    if (T!=NULL)
    {
        if (h < k)
        {
            nodeofH(T->left, h + 1, k, n);
            nodeofH(T->right, h + 1, k, n);
        }
        else
            n++;
    }
}

```



判断两颗树是不是相似树(结构一样)

```c++
bool likeTree(TreeNode* T1, TreeNode* T2) {
    if (T1==NULL&T2==NULL)
    {
        return true;
    }
    else if (T1==NULL||T2==NULL) {
        return false;
    }
    else {
        return  likeTree(T1->left, T2->left) && likeTree(T1->right, T2->right);
    }

}

```

输出结点为x的所有祖先

```c++
bool ancestor(TreeNode* T, int x) {
    if (T==NULL)
    {
        return false;
    }
    if (T->left!=NULL&&T->left->data==x||T->right!=NULL&&T->right->data==x)
    {
        cout << T->data;
        return true;
    }
    else {
        if (ancestor(T->left, x)|| ancestor(T->right, x))
        {
            cout << T->data;
            return true;
        }
    }
}
```

