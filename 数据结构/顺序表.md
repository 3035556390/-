顺序表

定义

```c++
const int Maxsize = 1000;
typedef struct {
    int data[Maxsize];
    int length;
};
```

建立

```c++
void CreateList(SqList*& L, int a[], int n) {
    L = (SqList*)malloc(sizeof(SqList));
    for (int i = 0; i < n; i++)
    {
        L->data[i] = a[i];
    }
     L->length = n;
}
```



int *&p;

```
void modifyPointer(int*& ptr) {
    int b = 20;
    ptr = &b; // 现在ptr引用的指针指向了变量 b
}

int main() {
    int a = 10;
    int* p = &a;
    modifyPointer(p); // p 现在指向了变量 b
    return 0;
}
```

在 `modifyPointer` 函数中，通过引用传递 `p`，我们实际上改变了 `p` 指针的值，使其指向了新的变量 `b`。如果只是使用 `int* p` 作为参数，那么函数内部对 `p` 的任何赋值都不会影响原始的 `p` 指针。

总结：

- `int* p` 是一个指针变量。
- `int*& p` 是一个引用，它引用了一个指针变量。



初始化

```c++
void InitList(SqList*& L) {
    L = (SqList*)malloc(sizeof(SqList));
    L->length = 0;
}
```

销毁

```c++
void DestroyList(SqList*& L) {
    free(L);
}
```

判空

```c++
bool ListEmpty(SqList*& L) {
    return L->length == 0;
}
```

插入

```c++
bool ListInsert(SqList*&L,int location,int element) {
    if (location<1||location>L->length+1)
    {
        return false;
    }
    location--;  //将逻辑结构位置转化为物理结构位置
    for (int i =L->length ; i>location; i--)
    {
        L->data[i] = L->data[i - 1];
    }
    L->data[location] = element;
    L->length++;
    return true;
}
```

删除

```c++
bool ListDelete(SqList*& L, int location, int e) {
    if (location<1 || location>L->length + 1)
    {
        return false;
    }
    location--;
    e = L->data[location];
    for (int i = location; i < L->length; i++)
    {
        L->data[i] = L->data[i + 1];
    }
    L->length--;
}
```

